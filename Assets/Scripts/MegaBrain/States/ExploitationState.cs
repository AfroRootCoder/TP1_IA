using System.Collections.Generic;
using UnityEngine;
using Vector2 = UnityEngine.Vector2;

public class ExploitationState : BrainState
{
    private const float APPROXIMATED_WORKER_SPEED = 5.0f;
    private bool m_hasToKeepExploring = false;
    private bool m_hasToJumpToDoomState = false;
    private int m_minimumWorkersAmountPerCamp = 0;
    public List<Collectible> AvailableCollectibles { get; private set; } = new List<Collectible>();
    public List<Collectible> NonAvailableCollectibles { get; private set; } = new List<Collectible>();

    public List<Worker> AvailableWorkersList { get; private set; } = new List<Worker>();
    public List<Worker> AvailableWorkersToRemove { get; private set; } = new List<Worker>();

    public List<Organisms> OrganismsList { get; private set; } = new List<Organisms>();

    public override void OnEnter()
    {
        Debug.Log("Entering ExploitationState");

        CalculateStrategyVariables();

        TeamOrchestrator._Instance.IncrementBoundingBox();
    }

    private void CalculateStrategyVariables()
    {
        Debug.Log("Collect: " + TeamOrchestrator._Instance.KnownCollectibles.Count);

        int campCost = MapGenerator.CampCost.Value;
        float workerCost = MapGenerator.WORKER_COST;
        float eachCampTotalRevenue = 0;
        float startingWorkersRevenue = 0;
        float strategyProjection = 0;

        if (TeamOrchestrator._Instance.KnownCollectibles.Count <= 1)
        {            
            Debug.Log("No Collectibles");
            m_hasToJumpToDoomState = true;
            return;
        }
        if (TeamOrchestrator._Instance.KnownCollectibles.Count < TeamOrchestrator.WORKERS_STARTING_AMOUNT)
        {
            Debug.Log("Not enough collectibles");
            LaunchMinimalExploitation(1);
            return;
        }

        float averageCollectiblesDistance = CalculateAverageCollectiblesDistance();        

        float averageDepositTime = averageCollectiblesDistance / APPROXIMATED_WORKER_SPEED;
        
        float estimatedTotalDepositsPerWorker = TeamOrchestrator._Instance.GetRemainingTime() / averageDepositTime;
        
        m_minimumWorkersAmountPerCamp = Mathf.CeilToInt((float)campCost / estimatedTotalDepositsPerWorker);
        
        eachCampTotalRevenue = (1 * m_minimumWorkersAmountPerCamp * estimatedTotalDepositsPerWorker) - campCost - (m_minimumWorkersAmountPerCamp * workerCost);
        Debug.Log("EachCampTotalRevenue: " + eachCampTotalRevenue);

        int startingWorkersCampsAmount = Mathf.FloorToInt(TeamOrchestrator.WORKERS_STARTING_AMOUNT / m_minimumWorkersAmountPerCamp);
        startingWorkersRevenue = (startingWorkersCampsAmount * (1 * m_minimumWorkersAmountPerCamp * estimatedTotalDepositsPerWorker)) - (startingWorkersCampsAmount * campCost);

        strategyProjection = startingWorkersRevenue + eachCampTotalRevenue;
        Debug.Log("Final projection: " + strategyProjection);

        if (eachCampTotalRevenue > 0)
        {            
            LaunchMaximalExploitation();
            return;
        }

        LaunchMinimalExploitation(m_minimumWorkersAmountPerCamp);
    }

    private float CalculateAverageCollectiblesDistance()
    {
        float averageDistance = 1;

        foreach (var collectible in TeamOrchestrator._Instance.KnownCollectibles)
        {
            float smallestDistance = 1000;
            foreach (var coll in TeamOrchestrator._Instance.KnownCollectibles)
            {
                if (coll == collectible)
                {
                    continue;
                }

                float dist = Vector2.Distance(collectible.GetPosition(), coll.GetPosition());
                if (dist < smallestDistance)
                {
                    smallestDistance = dist;
                }
            }

            if (collectible == TeamOrchestrator._Instance.KnownCollectibles[0])
            {
                averageDistance = smallestDistance;
            }
            else
            {
                averageDistance = (averageDistance + smallestDistance) / 2;
            }
        }

        return averageDistance;
    }

    private void LaunchMaximalExploitation()
    {
        int amountToSpawn = TeamOrchestrator.MAX_WORKERS - TeamOrchestrator.WORKERS_STARTING_AMOUNT;
        for (int i = 0; i < amountToSpawn; i++)
        {
            TeamOrchestrator._Instance.SpawnWorker();
        }

        foreach (var worker in TeamOrchestrator._Instance.WorkersList)
        {
            AvailableWorkersList.Add(worker);
        }

        SetUpOrganisms();
    }

    private void LaunchMinimalExploitation(int workerAmountPerCamp)
    {
        int workerAmount = workerAmountPerCamp;
        while (workerAmount <= TeamOrchestrator.WORKERS_STARTING_AMOUNT)
        {
            workerAmount += workerAmountPerCamp;
        }

        if (TeamOrchestrator._Instance.KnownCollectibles.Count > TeamOrchestrator.WORKERS_STARTING_AMOUNT)
        {
            int amountToSpawn = workerAmount - TeamOrchestrator.WORKERS_STARTING_AMOUNT;
            for (int i = 0; i < amountToSpawn; i++)
            {
                TeamOrchestrator._Instance.SpawnWorker();
            }
        }

        foreach (var worker in TeamOrchestrator._Instance.WorkersList)
        {
            AvailableWorkersList.Add(worker);
        }

        SetUpOrganisms();
    }



    private void SetUpOrganisms()
    {
        UpdateAvailableCollectiblesList();

        if (AvailableWorkersList.Count == 0)
        {
            Debug.Log("No workers");
            return;
        }
        if (AvailableCollectibles.Count == 0)
        {
            Debug.Log("No collectibles");
            return;
        }

        if (AvailableWorkersList.Count == 1)
        {
            return;
        }
        Debug.Log("SetUp workerAmount: " + AvailableWorkersList.Count);


        Collectible firstCollectible = FindClosestCollectibleToOrigin();

        Collectible secondCollectible = FindAnotherCollectibleAtIdealDistance(firstCollectible);

        if (secondCollectible == null)
        {
            Debug.Log("No scnd Collectible");
            return;
        }

        Vector2 middlePoint = (firstCollectible.GetPosition() + secondCollectible.GetPosition()) / 2;
        float collectiblesRange = Vector2.Distance(firstCollectible.GetPosition(), secondCollectible.GetPosition());
        List<Vector2> collectibleGroup = FindAllCollectiblesInsideChosenRange(middlePoint, collectiblesRange) ;

        List<Worker> workerGroup = CreateWorkerGroup(collectibleGroup.Count);

        Organisms newOrganism = new Organisms(collectibleGroup.Count, collectibleGroup, workerGroup);
        OrganismsList.Add(newOrganism);

        RemoveItemsFromList();

        Debug.Log("End ---------------------------------------------------------------------------------------");

        SetUpOrganisms();
    }

    private Collectible FindClosestCollectibleToOrigin()
    {
        Collectible closestCollectible = AvailableCollectibles[0];
        foreach (var collectible in AvailableCollectibles)
        {
            if (collectible == AvailableCollectibles[0])
            {
                continue;
            }
            if (Vector2.Distance(collectible.GetPosition(), Vector2.zero) <
                Vector2.Distance(closestCollectible.GetPosition(), Vector2.zero))
            {
                closestCollectible = collectible;
            }
        }

        return closestCollectible;
    }

    private Collectible FindAnotherCollectibleAtIdealDistance(Collectible firstCollectible)
    {
        Collectible secondCollectible = null;
        
        float closestDistance = 100;
        foreach (var collectible in AvailableCollectibles)
        {
            if (collectible == firstCollectible)
            {
                continue;
            }

            float distance = Vector2.Distance(collectible.GetPosition(), firstCollectible.GetPosition());
            if (distance > 20 && distance < closestDistance)
            {
                secondCollectible = collectible;
                closestDistance = distance;
            }
        }

        return secondCollectible;
    }

    private List<Vector2> FindAllCollectiblesInsideChosenRange(Vector2 middlePoint, float range)
    {
        List<Vector2> collectibleGroup = new List<Vector2>();

        foreach (var collectible in AvailableCollectibles)
        {
            if (Vector2.Distance(middlePoint, collectible.GetPosition()) < range) 
            {
                if (collectibleGroup.Count >= AvailableWorkersList.Count)
                {
                    break;
                }
                collectibleGroup.Add(collectible.GetPosition());
                NonAvailableCollectibles.Add(collectible);
                Debug.Log("Being assigned: " + collectible.GetPosition());
            }
        }

        return collectibleGroup;
    }

    private List<Worker> CreateWorkerGroup(int numberOfCollectibles)
    {
        List<Worker> workerGroup = new List<Worker>();

        for (int i = 0; i < numberOfCollectibles; i++)
        {

            workerGroup.Add(AvailableWorkersList[i]);
            AvailableWorkersToRemove.Add(AvailableWorkersList[i]);
        }

        return workerGroup;
    }

    private void UpdateAvailableCollectiblesList()
    {
        int loops = TeamOrchestrator._Instance.KnownCollectibles.Count;
        Debug.Log("Known Collectibles: " + loops);

        Debug.Log("number of nonAvailable: " + NonAvailableCollectibles.Count);
        for (int i = 0; i < loops; i++)
        {
            bool notAvailable = false;
            foreach (var nonAvailable in NonAvailableCollectibles)
            {
                if (TeamOrchestrator._Instance.KnownCollectibles[i].GetPosition() == nonAvailable.GetPosition())
                {                    
                    notAvailable = true;
                    break;
                }

            }
            if (notAvailable == false)
            {                
                AvailableCollectibles.Add(TeamOrchestrator._Instance.KnownCollectibles[i]);
            }

        }
        Debug.Log("AvailableCollect: " + AvailableCollectibles.Count);
    }

    public override void OnFixedUpdate()
    {
        if (m_hasToKeepExploring == true)
        {
            if (TeamOrchestrator._Instance.KnownCollectibles.Count > 1)
            {
                m_hasToKeepExploring = false;
                CalculateStrategyVariables();
            }
        }

    }

    public override void OnUpdate()
    {
    }

    private void RemoveItemsFromList()
    {
        if (AvailableWorkersToRemove.Count != 0)
        {
            foreach (var workerToRemove in AvailableWorkersToRemove)
            {
                foreach (var worker in AvailableWorkersList)
                {
                    if (workerToRemove == worker)
                    {
                        AvailableWorkersList.Remove(worker);
                        Debug.Log(worker.name + " not available anymore");
                        break;
                    }
                }
            }
            AvailableWorkersToRemove.Clear();
            Debug.Log("AvailableWorkers: " + AvailableWorkersList.Count);
        }

        AvailableCollectibles.Clear();
    }

    public override void OnExit()
    {
        Debug.Log("Exiting ExploitationState");

        foreach (var worker in TeamOrchestrator._Instance.WorkersList)
        {
            worker.SetIsAssignedBool(false);
        }
    }

    public override bool CanEnter(IState currentState)
    {
        return m_stateMachine.m_stateTimer >
            m_stateMachine.ExplorationStateDuration;
    }

    public override bool CanExit()
    {
        return TeamOrchestrator._Instance.GetRemainingTime() < 100.0f ||
            m_hasToJumpToDoomState;
    }
}

