using System.Collections.Generic;
using System.Numerics;
using UnityEngine;
using Vector2 = UnityEngine.Vector2;

public class ExploitationState : BrainState
{
    private const int BOUNDING_BOX_INCREMENTATION = 10;

    private bool m_hasToKeepExploring = false;

    private int m_minimumWorkersAmountPerCamp = 0;

    private int m_boundingBoxMultiplier = 1;

    public List<Collectible> AvailableCollectibles { get; private set; } = new List<Collectible>();
    public List<Collectible> NonAvailableCollectibles { get; private set; } = new List<Collectible>();

    public List<Worker> AvailableWorkersList { get; private set; } = new List<Worker>();
    public List<Worker> AvailableWorkersToRemove { get; private set; } = new List<Worker>();


    public List<Organisms> OrganismsList { get; private set; } = new List<Organisms>();

    public override void OnEnter()
    {
        Debug.Log("Entering ExploitationState");

        TeamOrchestrator._Instance.ReadjustBoundingBox();
        CalculateStrategyVariables();
    }

    //private void ReadjustBoundingBox()
    //{
    //    float incrementation = BOUNDING_BOX_INCREMENTATION * m_boundingBoxMultiplier;
    //    Vector2 min = new Vector2(TeamOrchestrator._Instance.InitialBoundingBoxMin.x - incrementation, TeamOrchestrator._Instance.InitialBoundingBoxMin.y - incrementation);
    //    Vector2 max = new Vector2(TeamOrchestrator._Instance.InitialBoundingBoxMin.x + incrementation, TeamOrchestrator._Instance.InitialBoundingBoxMin.y + incrementation);
    //
    //    m_boundingBoxMultiplier++;
    //    TeamOrchestrator._Instance.GenerateSearchGridAreaBoundingBox(min,max);
    //}

    private void CalculateStrategyVariables()
    {
        Debug.Log("Collect: " + TeamOrchestrator._Instance.KnownCollectibles.Count);


        int campCost = MapGenerator.CampCost.Value;
        float workerCost = MapGenerator.WORKER_COST; //20
        float eachCampTotalRevenue = 0;
        float startingWorkersRevenue = 0;
        float strategyProjection = 0;

        if (TeamOrchestrator._Instance.KnownCollectibles.Count < 2)
        {
            //Extend exploration
            Debug.Log("Need more exploration");
            m_hasToKeepExploring = true;
            return;
        }


        float averageCollectiblesDistance = CalculateAverageCollectiblesDistance();
        //Debug.Log("avCollectibDistance: " + averageCollectiblesDistance);

        float averageDepositTime = averageCollectiblesDistance / 5.0f; //approximated WorkerSpeed TO.IMPROVE    // In seconds
        //Debug.Log("avDepositTime: " + averageDepositTime);

        float estimatedTotalDepositsPerWorker = TeamOrchestrator._Instance.GetRemainingTime() / averageDepositTime; // Per worker
        //Debug.Log("estimatedTotalDepositsPerWorker: " + estimatedTotalDepositsPerWorker);


        m_minimumWorkersAmountPerCamp = Mathf.CeilToInt((float)campCost / estimatedTotalDepositsPerWorker);
        //Debug.Log("minimumWorkers: " + minimumWorkerAmountPerCamp);

        eachCampTotalRevenue = (1 * m_minimumWorkersAmountPerCamp * estimatedTotalDepositsPerWorker) - campCost - (m_minimumWorkersAmountPerCamp * workerCost);
        Debug.Log("EachCampTotalRevenue: " + eachCampTotalRevenue); //Considering no available workers

        int startingWorkersCampsAmount = Mathf.FloorToInt(TeamOrchestrator.WORKERS_STARTING_AMOUNT / m_minimumWorkersAmountPerCamp);
        startingWorkersRevenue = (startingWorkersCampsAmount * (1 * m_minimumWorkersAmountPerCamp * estimatedTotalDepositsPerWorker)) - (startingWorkersCampsAmount * campCost);

        strategyProjection = startingWorkersRevenue + eachCampTotalRevenue;
        Debug.Log("Final projection" + strategyProjection);

        if (eachCampTotalRevenue > 0)
        {
            //LaunchAllInStrategy
            LaunchMaximalExploitation();
            return;
        }

        LaunchMinimalExploitation(m_minimumWorkersAmountPerCamp);
    }

    private float CalculateAverageCollectiblesDistance()
    {
        float averageDistance = 1;

        foreach (var collectible in TeamOrchestrator._Instance.KnownCollectibles)
        {
            float smallestDistance = 1000;
            foreach (var coll in TeamOrchestrator._Instance.KnownCollectibles)
            {
                if (coll == collectible)
                {
                    continue;
                }

                float dist = Vector2.Distance(collectible.GetPosition(), coll.GetPosition());
                if (dist < smallestDistance)
                {
                    smallestDistance = dist;
                }
            }

            if (collectible == TeamOrchestrator._Instance.KnownCollectibles[0])
            {
                averageDistance = smallestDistance;
            }
            else
            {
                averageDistance = (averageDistance + smallestDistance) / 2;
            }
        }

        return averageDistance;
    }

    private void LaunchMaximalExploitation()
    {
        int amountToSpawn = TeamOrchestrator.MAX_WORKERS - TeamOrchestrator.WORKERS_STARTING_AMOUNT;
        for (int i = 0; i < amountToSpawn; i++)
        {
            TeamOrchestrator._Instance.SpawnWorker();
        }

        foreach (var worker in TeamOrchestrator._Instance.WorkersList)
        {
            AvailableWorkersList.Add(worker);
        }

        SetUpOrganisms();
    }

    private void LaunchMinimalExploitation(int workerAmountPerCamp)
    {
        int workerAmount = workerAmountPerCamp;
        while (workerAmount <= TeamOrchestrator.WORKERS_STARTING_AMOUNT)
        {
            workerAmount += workerAmountPerCamp;
        }

        if (TeamOrchestrator._Instance.KnownCollectibles.Count > TeamOrchestrator.WORKERS_STARTING_AMOUNT)
        {
            int amountToSpawn = workerAmount - TeamOrchestrator.WORKERS_STARTING_AMOUNT;
            for (int i = 0; i < amountToSpawn; i++)
            {
                TeamOrchestrator._Instance.SpawnWorker();
            }
        }

        foreach (var worker in TeamOrchestrator._Instance.WorkersList)
        {
            AvailableWorkersList.Add(worker);
        }

        SetUpOrganisms();
    }

    private void SetUpOrganisms()
    {
        UpdateAvailableCollectiblesList();

        if (AvailableWorkersList.Count == 0)
        {
            Debug.Log("No workers");
            return;
        }
        if (AvailableCollectibles.Count == 0)
        {
            Debug.Log("No collectibles");
            return;
        }
        Debug.Log("SetUp workerAmount: " + AvailableWorkersList.Count);


        Collectible firstCollectible = FindClosestCollectibleToOrigin();

        Collectible secondCollectible = FindAnotherCollectibleAtIdealDistance(firstCollectible);

        //There shouldnt be a new Organism if collectibles are too far apart
        if (secondCollectible == null)
        {
            Debug.Log("No scnd Collectible");
            return;
            //Deal with last two workers
        }

        Vector2 middlePoint = (firstCollectible.GetPosition() + secondCollectible.GetPosition()) / 2;
        float collectiblesRange = Vector2.Distance(firstCollectible.GetPosition(), secondCollectible.GetPosition());
        List<Vector2> collectibleGroup = FindAllCollectiblesInsideChosenRange(middlePoint, collectiblesRange) ;

        List<Worker> workerGroup = CreateWorkerGroup(collectibleGroup.Count);

        Organisms newOrganism = new Organisms(collectibleGroup.Count, collectibleGroup, workerGroup);
        OrganismsList.Add(newOrganism);


        RemoveItemsFromList();

        Debug.Log("End ---------------------------------------------------------------------------------------");

        SetUpOrganisms();
    }

    private Collectible FindClosestCollectibleToOrigin()
    {
        Collectible closestCollectible = AvailableCollectibles[0];
        foreach (var collectible in AvailableCollectibles)
        {
            if (collectible == AvailableCollectibles[0])
            {
                continue;
            }
            if (Vector2.Distance(collectible.GetPosition(), Vector2.zero) <
                Vector2.Distance(closestCollectible.GetPosition(), Vector2.zero))
            {
                closestCollectible = collectible;
            }
        }

        return closestCollectible;
    }

    private Collectible FindAnotherCollectibleAtIdealDistance(Collectible firstCollectible)
    {
        Collectible secondCollectible = null;
        
        float closestDistance = 100;
        foreach (var collectible in AvailableCollectibles)
        {
            if (collectible == firstCollectible)
            {
                continue;
            }

            float distance = Vector2.Distance(collectible.GetPosition(), firstCollectible.GetPosition());
            if (distance > 20 && distance < closestDistance)
            {
                secondCollectible = collectible;
                closestDistance = distance;
            }
        }

        return secondCollectible;
    }

    private List<Vector2> FindAllCollectiblesInsideChosenRange(Vector2 middlePoint, float range)
    {
        List<Vector2> collectibleGroup = new List<Vector2>();

        foreach (var collectible in AvailableCollectibles)
        {
            if (Vector2.Distance(middlePoint, collectible.GetPosition()) < range) 
            {
                if (collectibleGroup.Count >= AvailableWorkersList.Count)
                {
                    break;
                }
                collectibleGroup.Add(collectible.GetPosition());
                NonAvailableCollectibles.Add(collectible);
                Debug.Log("Being assigned: " + collectible.GetPosition());
            }
        }

        return collectibleGroup;
    }

    private List<Worker> CreateWorkerGroup(int numberOfCollectibles)
    {
        List<Worker> workerGroup = new List<Worker>();

        for (int i = 0; i < numberOfCollectibles; i++)
        {

            workerGroup.Add(AvailableWorkersList[i]);
            AvailableWorkersToRemove.Add(AvailableWorkersList[i]);
        }

        return workerGroup;
    }

    private void UpdateAvailableCollectiblesList()
    {
        int loops = TeamOrchestrator._Instance.KnownCollectibles.Count;
        Debug.Log("Known Collectibles: " + loops);

        Debug.Log("number of nonAvailable: " + NonAvailableCollectibles.Count);
        for (int i = 0; i < loops; i++)
        {
            bool notAvailable = false;
            foreach (var nonAvailable in NonAvailableCollectibles)
            {
                if (TeamOrchestrator._Instance.KnownCollectibles[i].GetPosition() == nonAvailable.GetPosition())
                {
                    //Debug.Log("Not available: " + nonAvailable.GetPosition());
                    notAvailable = true;
                    break;
                }

            }
            if (notAvailable == false)
            {
                //Debug.Log("Added" + TeamOrchestrator._Instance.KnownCollectibles[i].GetPosition());
                AvailableCollectibles.Add(TeamOrchestrator._Instance.KnownCollectibles[i]);
            }

        }
        Debug.Log("AvailableCollect: " + AvailableCollectibles.Count);
    }

    public override void OnFixedUpdate()
    {
        if (m_hasToKeepExploring == true)
        {
            if (TeamOrchestrator._Instance.KnownCollectibles.Count > 1)
            {
                m_hasToKeepExploring = false;
                CalculateStrategyVariables();
            }
        }

    }

    public override void OnUpdate()
    {
    }

    private void RemoveItemsFromList()
    {
        if (AvailableWorkersToRemove.Count != 0)
        {
            foreach (var workerToRemove in AvailableWorkersToRemove)
            {
                foreach (var worker in AvailableWorkersList)
                {
                    if (workerToRemove == worker)
                    {
                        AvailableWorkersList.Remove(worker);
                        Debug.Log(worker.name + " not available anymore");
                        break;
                    }
                }
            }
            AvailableWorkersToRemove.Clear();
            Debug.Log("AvailableWorkers: " + AvailableWorkersList.Count);
        }

        AvailableCollectibles.Clear();
    }

    public override void OnExit()
    {
        Debug.Log("Exiting ExploitationState");
    }

    public override bool CanEnter(IState currentState)
    {
        return m_stateMachine.m_stateTimer >
            m_stateMachine.ExplorationStateDuration;
    }
    public override bool CanExit()
    {
        return TeamOrchestrator._Instance.GetRemainingTime() < 100.0f;
    }
}

