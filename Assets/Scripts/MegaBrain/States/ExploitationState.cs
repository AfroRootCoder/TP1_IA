using System.Collections;
using System.Collections.Generic;
using System.Numerics;
using Unity.VisualScripting;
using UnityEngine;
using Vector2 = UnityEngine.Vector2;

public class ExploitationState : BrainState
{
    private bool m_hasToKeepExploring = false;
    private float m_recalculatingTimer = 0;

    public List<Collectible> AvailableCollectibles { get; private set; } = new List<Collectible>();
    public List<Collectible> NonAvailableCollectibles { get; private set; } = new List<Collectible>();

    public List<Worker> AvailableWorkersList { get; private set; } = new List<Worker>();
    public List<Worker> AvailableWorkersToRemove { get; private set; } = new List<Worker>();


    public List<Organisms> OrganismsList { get; private set; } = new List<Organisms>();

    public override void OnEnter()
    {
        Debug.Log("Entering ExploitationState");

        //TeamOrchestrator._Instance.InitializeExploitationPhase();
        CalculateStrategyVariables();
    }

    private void CalculateStrategyVariables()
    {
        //Debug.Log("Time: " + TeamOrchestrator._Instance.GetRemainingTime());
        Debug.Log("Collect: " + TeamOrchestrator._Instance.KnownCollectibles.Count);


        int campCost = MapGenerator.CampCost.Value;
        float workerCost = MapGenerator.WORKER_COST; //20
        //m_remainingTime
        int minimumWorkerAmountPerCamp = 0;
        float eachCampTotalRevenue = 0;
        float societyTotalRevenue = 0;


        if (TeamOrchestrator._Instance.KnownCollectibles.Count < 2)
        {
            //Extend exploration
            Debug.Log("Need more exploration");
            m_hasToKeepExploring = true;
            return;
        }


        float averageCollectiblesDistance = CalculateAverageCollectiblesDistance();
        //Debug.Log("avCollectibDistance: " + averageCollectiblesDistance);

        float averageDepositTime = averageCollectiblesDistance / 5.0f; //approximated WorkerSpeed TO.IMPROVE    // In seconds
        //Debug.Log("avDepositTime: " + averageDepositTime);

        float estimatedTotalDepositsPerWorker = TeamOrchestrator._Instance.GetRemainingTime() / averageDepositTime; // Per worker
        //Debug.Log("estimatedTotalDepositsPerWorker: " + estimatedTotalDepositsPerWorker);


        minimumWorkerAmountPerCamp = Mathf.CeilToInt((float)campCost / estimatedTotalDepositsPerWorker);
        //Debug.Log("minimumWorkers: " + minimumWorkerAmountPerCamp);

        eachCampTotalRevenue = (1 * minimumWorkerAmountPerCamp * estimatedTotalDepositsPerWorker) - campCost - (minimumWorkerAmountPerCamp * workerCost);
        Debug.Log("campTotalRevenue: " + eachCampTotalRevenue); //Considering no available workers

        if (eachCampTotalRevenue > 0)
        {
            //LaunchAllInStrategy
            LaunchMaximalExploitation();
            return;
        }

        int nbWorkers = 5;
        while (nbWorkers > 0)
        {
            if (nbWorkers < minimumWorkerAmountPerCamp)
            {
                //Spawn needed
            }

            societyTotalRevenue += (1 * minimumWorkerAmountPerCamp * estimatedTotalDepositsPerWorker) - campCost;
            nbWorkers -= minimumWorkerAmountPerCamp;
        }

        //Debug.Log("using av. workers Income: " + societyTotalRevenue);
        //societyTotalRevenue += (1 * minimumWorkerAmountPerCamp * estimatedTotalDepositsPerWorker) - campCost - (minimumWorkerAmountPerCamp * workerCost);


        /////////////////////////////////////////////








    }
    private float CalculateAverageCollectiblesDistance()
    {
        //List<Collectible> knownCollectiblesList = TeamOrchestrator._Instance.KnownCollectibles;

        float averageDistance = 1;

        foreach (var collectible in TeamOrchestrator._Instance.KnownCollectibles)
        {
            float smallestDistance = 1000;
            foreach (var coll in TeamOrchestrator._Instance.KnownCollectibles)
            {
                if (coll == collectible)
                {
                    continue;
                }

                float dist = Vector2.Distance(collectible.GetPosition(), coll.GetPosition());
                if (dist < smallestDistance)
                {
                    smallestDistance = dist;
                    //Debug.Log("smaller " + smallestDistance);
                }
            }

            if (collectible == TeamOrchestrator._Instance.KnownCollectibles[0])
            {
                averageDistance = smallestDistance;
            }
            else
            {
                averageDistance = (averageDistance + smallestDistance) / 2;
                //Debug.Log("average " + averageDistance);
            }

        }

        return averageDistance;
    }

    private void LaunchMaximalExploitation()
    {
        //Spawn Max Workers
        int amountToSpawn = TeamOrchestrator.MAX_WORKERS - TeamOrchestrator.WORKERS_STARTING_AMOUNT;
        for (int i = 0; i < amountToSpawn; i++)
        {
            TeamOrchestrator._Instance.SpawnWorker();
        }

        //AvailableWorkersList = TeamOrchestrator._Instance.WorkersList;
        foreach (var worker in TeamOrchestrator._Instance.WorkersList)
        {
            AvailableWorkersList.Add(worker);
        }

        //AvailableCollectibles = TeamOrchestrator._Instance.KnownCollectibles; //NO GOOD
        //should keep all discovered collectibles and seperate used ones differently
        //list of all known
        //list of assigned
        //list of remaining



        SetUpOrganisms();
    }

    private void SetUpOrganisms()
    {
        UpdateAvailableCollectiblesList();

        if (AvailableWorkersList.Count == 0)
        {
            Debug.Log("No workers");
            return;
        }
        if (AvailableCollectibles.Count == 0)
        {
            Debug.Log("No collectibles");
            return;
        }
        Debug.Log("SetUp workerAmount: " + AvailableWorkersList.Count);


        //Find closest to origin

        Collectible closestCollectible = AvailableCollectibles[0];
        foreach (var collectible in AvailableCollectibles)
        {
            if (collectible == AvailableCollectibles[0])
            {
                continue;
            }
            if (Vector2.Distance(collectible.GetPosition(), Vector2.zero) <
                Vector2.Distance(closestCollectible.GetPosition(), Vector2.zero))
            {
                closestCollectible = collectible;
            }
        }
        Collectible firstCollectible = closestCollectible;
        Collectible secondCollectible = null;
        //Debug.Log("first Collectible: " + firstCollectible.GetPosition());

        //Find other collect at >15 but closest
        float closestDistance = 100;
        foreach (var collectible in AvailableCollectibles)
        {
            if (collectible == firstCollectible)
            {
                continue;
            }

            float distance = Vector2.Distance(collectible.GetPosition(), firstCollectible.GetPosition());
            if (distance > 20 && distance < closestDistance)
            {
                secondCollectible = collectible;
                closestDistance = distance;
            }
        }
        //Debug.Log("second Collectible: " + secondCollectible.GetPosition());

        //There shouldnt be a new Organism if collectibles are too far apart
        if (secondCollectible == null)
        {
            Debug.Log("No scnd Collectible");
            return;
            //Deal with last two workers
        }

        //Find center point aka camp Placement
        Vector2 middlePoint = (firstCollectible.GetPosition() + secondCollectible.GetPosition()) / 2;
        //Debug.Log("Middle Point: " + middlePoint);

        //Find all collectibles inside chosen range
        //Create List of all those collectibles
        List<Vector2> collectibleGroup = new List<Vector2>();

        foreach (var collectible in AvailableCollectibles)
        {
            if (Vector2.Distance(middlePoint, collectible.GetPosition()) < closestDistance) //ideal would be 20
            {
                if (collectibleGroup.Count >= AvailableWorkersList.Count)
                {
                    break;
                }
                collectibleGroup.Add(collectible.GetPosition());
                NonAvailableCollectibles.Add(collectible);
                Debug.Log("Being assigned: " + collectible.GetPosition());
            }
        }
        Debug.Log("collectibleGroup: " + collectibleGroup.Count);

        List<Worker> workerGroup = new List<Worker>();
        for (int i = 0; i < collectibleGroup.Count; i++)
        {
            
            workerGroup.Add(AvailableWorkersList[i]);
            AvailableWorkersToRemove.Add(AvailableWorkersList[i]);
        }

        Organisms newOrganism = new Organisms(collectibleGroup.Count, collectibleGroup, workerGroup);
        OrganismsList.Add(newOrganism);


        RemoveItemsFromList();

        Debug.Log("End ---------------------------------------------------------------------------------------");

        SetUpOrganisms();
    }

    private void UpdateAvailableCollectiblesList()
    {
        int loops = TeamOrchestrator._Instance.KnownCollectibles.Count;
        Debug.Log("Known Collectibles: " + loops);

        Debug.Log("number of nonAvailable: " + NonAvailableCollectibles.Count);
        for (int i = 0; i < loops; i++)
        {
            bool notAvailable = false;
            foreach (var nonAvailable in NonAvailableCollectibles)
            {
                if (TeamOrchestrator._Instance.KnownCollectibles[i].GetPosition() == nonAvailable.GetPosition())
                {
                    //Debug.Log("Not available: " + nonAvailable.GetPosition());
                    notAvailable = true;
                    break;
                }

            }
            if (notAvailable == false)
            {
                //Debug.Log("Added" + TeamOrchestrator._Instance.KnownCollectibles[i].GetPosition());
                AvailableCollectibles.Add(TeamOrchestrator._Instance.KnownCollectibles[i]);
            }

        }
        Debug.Log("AvailableCollect: " + AvailableCollectibles.Count);
    }

    public override void OnFixedUpdate()
    {
        if (m_hasToKeepExploring == true)
        {
            if (TeamOrchestrator._Instance.KnownCollectibles.Count > 1)
            {
                m_hasToKeepExploring = false;
                CalculateStrategyVariables();
            }
        }

        //m_recalculatingTimer += Time.fixedDeltaTime;
        //if (m_recalculatingTimer > 30)
        //{
        //    if (AvailableCollectibles.Count > 0 /*&&
        //        AvailableWorkersList.Count > 0*/)
        //    {
        //        Debug.Log("***************************Recalculating*******************************");
        //        SetUpOrganisms();
        //    }
        //    m_recalculatingTimer = 0;
        //}
    }

    public override void OnUpdate()
    {
    }

    private void RemoveItemsFromList()
    {
        if (AvailableWorkersToRemove.Count != 0)
        {
            foreach (var workerToRemove in AvailableWorkersToRemove)
            {
                foreach (var worker in AvailableWorkersList)
                {
                    if (workerToRemove == worker)
                    {
                        AvailableWorkersList.Remove(worker);
                        Debug.Log(worker.name + " not available anymore");
                        break;
                    }
                }
            }
            AvailableWorkersToRemove.Clear();
            Debug.Log("AvailableWorkers: " + AvailableWorkersList.Count);
        }

        AvailableCollectibles.Clear();

        /*if (AvailableCollectiblesToRemove.Count != 0)
        {
            foreach (var collectibleToRemove in AvailableCollectiblesToRemove)
            {
                foreach (var collectible in AvailableCollectibles)
                {
                    if (collectibleToRemove.GetPosition() == collectible.GetPosition())
                    {
                        AvailableCollectibles.Remove(collectible);
                        Debug.Log(collectible.name + collectible.GetPosition() + " not available anymore");
                        break;
                    }
                }
            }
            AvailableCollectiblesToRemove.Clear();
            Debug.Log("Available Collectibles: " + AvailableCollectibles.Count);
        }*/
    }

    public override void OnExit()
    {
        Debug.Log("Exiting ExploitationState");
    }

    public override bool CanEnter(IState currentState)
    {
        return m_stateMachine.m_stateTimer >
            m_stateMachine.ExplorationStateDuration;
    }
    public override bool CanExit()
    {
        return TeamOrchestrator._Instance.GetRemainingTime() < 100.0f;
    }
}

public class Organisms
{
    private int m_collectiblesAmount;
    private List<Vector2> m_assignedCollectibles;
    private Vector2 m_campPlacement;
    private List<Worker> m_assignedWorkers;

    public Organisms(int amount, List<Vector2> collectibles, List<Worker> workers)
    {
        m_collectiblesAmount = amount;
        m_assignedCollectibles = collectibles;
        m_assignedWorkers = workers;
        m_campPlacement = EvaluateCampPlacement();

        AssignWorkers();
    }

    private Vector2 EvaluateCampPlacement()
    {
        //Check for case of 1 collectible
        //will place camp on top of collectible
        //maybe frenzy mode ?
        
        Vector2 idealPosition = new Vector2();

        for (int i = 0; i < m_collectiblesAmount; i++)
        {
            idealPosition += m_assignedCollectibles[i];
        }
        idealPosition /= m_collectiblesAmount;

        return idealPosition;
    }

    private void AssignWorkers()
    {
        for (int i = 0; i < m_collectiblesAmount; i++)
        {
            m_assignedWorkers[i].SetIsAssignedBool(true);

            if (i == 0)
            {
                m_assignedWorkers[0].SetIsAssignedToBuildCampBool(true);
            }

            m_assignedWorkers[i].SetAssignedCollectiblePosition(m_assignedCollectibles[i]);
            m_assignedWorkers[i].SetAssignedCampPosition(m_campPlacement);

            float waitingTime = CalculateWaitingTime(m_assignedCollectibles[i]);
            m_assignedWorkers[i].SetWaitingTime(waitingTime);
        }
    }

    private float CalculateWaitingTime(Vector2 collectiblePos)
    {
        float distance = Vector2.Distance(collectiblePos, m_campPlacement);

        return 5 - (distance / 5); //CooldownTime - (distance / worker distance per second)
    }
}
